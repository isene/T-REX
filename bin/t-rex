#!/usr/bin/env ruby
# encoding: utf-8
#
# Title:      T-REX (Terminal - Rpn EXperiment)
# Language:   Pure Ruby, best viewed in VIM
# Author:     Geir Isene <g@isene.com> http://isene.com/
# Github:     https://github.com/isene/t-rex/
# License:    I release all copyright claims. This code is in the public domain.
#             Permission is granted to use, copy modify, distribute, and sell
#             this software for any purpose. I make no guarantee about the
#             suitability of this software for any purpose and I am not liable
#             for any damages resulting from its use. Further, I am under no
#             obligation to maintain or extend this software. It is provided 
#             on an 'as is' basis without any expressed or implied warranty.
@version    = "4.1.1" # Fix xrpn dependency version to ~> 2.7

require 'rcurses'
include Rcurses::Input

# Try to load XRPN for enhanced functionality
begin
  # XRPN is not a standard require, it's an executable
  # We need to load the XRPN class directly from the gem
  gem_path = `VISUAL=echo gem open xrpn 2>/dev/null`.chomp
  if gem_path && !gem_path.include?("Unable") && File.exist?(gem_path + "/xlib/xrpn_class")
    # Load the XRPN class
    load gem_path + "/xlib/xrpn_class"
    
    # Load essential utility functions (skip string to avoid conflicts with rcurses)
    %w[numeric fact convert_base].each do |lib|
      load gem_path + "/xlib/#{lib}" if File.exist?(gem_path + "/xlib/#{lib}")
    end
    
    # Load essential commands that we'll use for integration  
    # Load in dependency order: utility functions first, then operations
    essential_commands = %w[
      lift drop dropy enter
      add subtract multiply divide 
      ln log exp alog sin cos tan 
      sqrt sqr pow fact
      hexdec decbin decoct octdec
      lbl gto gsb rtn xeq stop view pse
    ]
    essential_commands.each do |cmd|
      begin
        load gem_path + "/xcmd/#{cmd}" if File.exist?(gem_path + "/xcmd/#{cmd}")
      rescue => e
        # Skip commands that fail to load
      end
    end
    
    XRPN_AVAILABLE = true
    XRPN_GEM_PATH = gem_path
  else
    XRPN_AVAILABLE = false
  end
rescue => e
  XRPN_AVAILABLE = false
end

def help # HELP text
help = <<HELPTEXT
  
  T-REX - Terminal Rpn calculator EXperiment. GitHub: https://github.com/isene/T-REX
  This is a Reverse Polish Notation calculator similar to the traditional Hewlett 
  Packard calculators. See https://www.hpmuseum.org/rpn.htm for info on RPN.
 
  The stack is shown to the top left. The X, Y, Z and  T registers comprise the 
  operating stack. L is the "Last X" register showing the previous value in X.
  Toggle US and European number formats by pressing '. 
 
  When entering a number into X, use 'h' to change the sign and 'e' to write an
  exponent (10^x). Entering "123e4" becomes "1230000". Use 'H' to enter a minus sign
  after an 'e' to get a negative exponent. Entering "123e-4" becomes "0.0123". 

  Functions available are shown under the stack registers. The orange symbol 
  corresponds to the key to be pressed. For functions above each label (grey 
  functions), press the Control key (Ctrl) and the orange key (asin = Ctrl+i).
  
  For Rectangular to Polar conversions:
  R-P: X value in x, Y in y - yields "θ" in y and "r" in x.
  P-R: "θ" in y and "r" in x - yields X in x and Y in y.

  Use the "f" key to set the fixed number of decimal places. Use the "s" key to set
  the limit for viewing numbers in the "scientific" notation (e.g. 5e+06 for 5000000).

  Toggle "ENG" (engineering notation) mode with Ctrl+E. In ENG mode, exponents are
  always multiples of 3 (e.g. 1230 becomes 1.2300e+003, 0.0045 becomes 4.5000e-003).
 
  Content of registers #0-#9 are shown below the functions.
  Store/recall using capital "S"/"R". "M" clears the regs.
 
  Copy/yank the X register to clipboard with "y". Use "Y" to yank all the memory regs.

  You can undo (with "u") all the way to the beginning of the session.

  The 'H' key toggles between the help text in the right pane or a continuous printout.
  Save the full printout to ~/t-rex.txt with "Ctrl-P".

  The stack, register contents, modes and help text settings are saved on Quit.

  Additionally, you can access the "Ruby mode" via '@'. Here you can address the stack 
  directly, e.g. 'x = y + (z / t); puts x'. Quit Ruby mode with ESC.

  Alternative keys: Left/Right keys (in addition to "<") exchanges X and Y registers. 
  Backspace clears the x register.

  Help pane scrolling: Shift+UP/DOWN (line by line), PgUP/PgDOWN (page by page), 
  HOME/END (top/bottom). Scroll indicators (∆/∇) show available content.

  == XRPN INTEGRATION ==
  Press 'X' to toggle between T-REX and XRPN calculation modes.
  
  To use XRPN features, install the gem first:
  From local repository: cd ~/Main/G/GIT-isene/xrpn && gem build xrpn.gemspec && gem install xrpn-*.gem
  Or when published: gem install xrpn
  
  In XRPN mode (press 'X' to toggle), enhanced functions are available:
  - Ctrl+F: Factorial function (with safety limits)
  - Ctrl+B: Number base conversions (hex, bin, oct, dec)  
  - P: Program execution panel (load and run XRPN programs) - ESC to exit
  - E: Program editor (create and edit XRPN programs) - ESC to exit
  - Enhanced precision and error handling for all mathematical operations
  
  Note: XRPN functions only work when toggled to XRPN mode.
  Both P and E modes support scrolling (Shift+UP/DOWN, PgUP/PgDOWN, HOME/END).
  
  XRPN mode provides access to 250+ mathematical functions from the XRPN language.
HELPTEXT
  if @hlp
    @p_hlp.fg = 239
    # Don't reset scroll position - preserve current @p_hlp.ix
    @p_hlp.say(help)
  else
    @p_hlp.ix = @history.length - @h + 3
    histprint
  end
end

class Stack # STACK class
  attr_accessor :x, :y, :z, :t, :l, :deg

  def initialize(x, y, z, t, l)
    self.x = x.to_f
    self.y = y.to_f
    self.z = z.to_f
    self.t = t.to_f
    self.l = l.to_f
  end
  def lift
    self.y, self.z, self.t = self.x, self.y, self.z
  end
  def drop
    self.y, self.z = self.z, self.t
  end
  def rdn
    self.x, self.y, self.z, self.t = self.y, self.z, self.t, self.x
  end
  def rup
    self.x, self.y, self.z, self.t = self.t, self.x, self.y, self.z
  end
  def xy
    self.x, self.y = self.y, self.x
  end
  def add
    self.l = self.x
    self.x = self.y + self.x
    self.drop
  end
  def subtract
    self.l = self.x
    self.x = self.y - self.x
    self.drop
  end
  def multiply
    self.l = self.x
    self.x = self.y * self.x
    self.drop
  end
  def divide
    begin
      raise if self.x == 0
      self.l = self.x
      self.x = self.y / self.x
      self.drop
    rescue
      return "Error"
    end
  end
  def mod
    begin
      raise if self.x == 0
      self.l = self.x
      self.x = self.y % self.x
      self.drop
    rescue
      return "Error"
    end
  end
  def percent
    begin
      raise if self.y == 0
      self.l = self.x
      self.x = 100*(self.x / self.y)
      self.drop
    rescue
      return "Error"
    end
  end
  def chs
    self.x = -self.x
  end
  def pi
    self.l = self.x
    self.lift
    self.x = Math::PI
  end
  def pow
    self.l = self.x
    self.x = self.y ** self.x
    self.drop
  end
  def root
    begin
      self.l = self.x
      self.x = self.y ** (1 / self.x)
      self.drop
    rescue
      return "Error"
    end
  end
  def recip
    begin
      raise if self.x == 0
      self.l = self.x
      self.x = 1 / self.x
    rescue
      return "Error"
    end
  end
  def sqr
    self.l = self.x
    self.x = self.x ** 2
  end
  def sqrt
    self.l = self.x
    begin
      self.x = Math::sqrt(self.x)
    rescue
      return "Error"
    end
  end
  def cube
    self.l = self.x
    self.x = self.x ** 3
  end
  def ln
    self.l = self.x
    begin
      self.x = Math::log(self.x)
    rescue
      return "Error"
    end
  end
  def ex
    self.l = self.x
    self.x = Math::exp(self.x)
  end
  def log
    self.l = self.x
    begin
      self.x = Math::log10(self.x)
    rescue
      return "Error"
    end
  end
  def tenx
    self.l = self.x
    self.x = 10 ** self.x
  end
  def sin
    self.l = self.x
    self.x = self.x * Math::PI / 180 if self.deg
    self.x = Math::sin(self.x)
  end
  def cos
    self.l = self.x
    self.x = self.x * Math::PI / 180 if self.deg
    self.x = Math::cos(self.x)
  end
  def tan
    self.l = self.x
    self.x = self.x * Math::PI / 180 if self.deg
    self.x = Math::tan(self.x)
  end
  def asin
    self.l = self.x
    begin
      self.x = Math::asin(self.x)
      self.x = self.x * 180 / Math::PI if self.deg 
    rescue
      return "Error"
    end
  end
  def acos
    self.l = self.x
    begin
      self.x = Math::acos(self.x)
      self.x = self.x * 180 / Math::PI if self.deg 
    rescue
      return "Error"
    end
  end
  def atan
    self.l = self.x
    self.x = Math::atan(self.x)
    self.x = self.x * 180 / Math::PI if self.deg 
  end
  def rp
    begin
      raise if self.x == 0
      self.l = self.x
      x = self.x
      y = self.y
      self.x = Math::sqrt(x*x + y*y)
      self.y = Math::atan(y/x)
      if x < 0  # Q2 & Q3
        self.y += Math::PI
      elsif x >= 0 and y < 0 # Q4
        self.y += 2 * Math::PI
      end
      self.y = self.y * 180 / Math::PI if self.deg
    rescue
      return "Error"
    end
  end
  def pr
    self.l = self.x
    r = self.x
    t = self.y
    t = t * Math::PI / 180 if self.deg
    self.x = r * Math::cos(t)
    self.y = r * Math::sin(t)
  end
end

class XrpnInterface # XRPN INTEGRATION CLASS
  attr_accessor :calc, :mode

  def initialize
    if XRPN_AVAILABLE
      @calc = XRPN.new(nil)  # XRPN class expects a file parameter, use nil for no file
      @mode = :trex  # :trex or :xrpn
      @available = true
    else
      @calc = nil
      @mode = :trex
      @available = false
    end
  end

  def available?
    @available
  end

  def toggle_mode
    return "XRPN not available" unless @available
    @mode = (@mode == :trex) ? :xrpn : :trex
  end

  def sync_stack_to_xrpn(stack)
    return unless @available
    @calc.t = stack.t
    @calc.z = stack.z
    @calc.y = stack.y
    @calc.x = stack.x
  end

  def sync_stack_from_xrpn
    return [0, 0, 0, 0] unless @available
    return [@calc.t, @calc.z, @calc.y, @calc.x]
  end

  def execute_xrpn_command(cmd)
    return "XRPN not available" unless @available
    begin
      # Check if it's a number first
      if cmd =~ /^-?\d+(\.\d+)?$/ || cmd =~ /^-?\.\d+$/
        # It's a number, enter it into the stack
        @calc.send('lift') if @calc.respond_to?('lift')
        @calc.x = cmd.to_f
        return true
      elsif @calc.respond_to?(cmd.downcase)
        # It's a command, execute it
        @calc.send(cmd.downcase)
        return true
      else
        return "Command not found: #{cmd}"
      end
    rescue => e
      return "Error: #{e.message}"
    end
  end

  def get_xrpn_functions
    {
      # Enhanced scientific functions
      'sinh' => 'SINH',
      'cosh' => 'COSH', 
      'tanh' => 'TANH',
      'asinh' => 'ASINH',
      'acosh' => 'ACOSH',
      'atanh' => 'ATANH',
      'gamma' => 'GAMMA',
      'factorial' => '!',
      'combination' => 'COMB',
      'permutation' => 'PERM',
      'gcd' => 'GCD',
      'lcm' => 'LCM',
      # Number base conversions
      'hex' => 'HEX',
      'bin' => 'BIN',
      'oct' => 'OCT',
      'dec' => 'DEC',
      # Statistical functions
      'mean' => 'MEAN',
      'sdev' => 'SDEV',
      'sum' => 'SUM',
      # Complex numbers
      'real' => 'REAL',
      'imag' => 'IMAG',
      'conj' => 'CONJ',
      'arg' => 'ARG'
    }
  end

  def mode_display
    if @available
      @mode == :xrpn ? "XRPN" : "T-REX"
    else
      "T-REX (XRPN N/A)"
    end
  end

  def debug_status
    "Available: #{@available}, Mode: #{@mode}"
  end

  def execute_with_sync(xrpn_cmd, stack)
    return "XRPN not available" unless @available
    sync_stack_to_xrpn(stack)
    result = execute_xrpn_command(xrpn_cmd)
    if result == true
      return sync_stack_from_xrpn
    else
      return result
    end
  end

  def load_program(filename)
    return "XRPN not available" unless @available
    begin
      @calc.load_program(filename)
      return true
    rescue => e
      return "Error: #{e.message}"
    end
  end

  def execute_program(program_name)
    return "XRPN not available" unless @available
    begin
      @calc.execute_program(program_name)
      return true
    rescue => e
      return "Error: #{e.message}"
    end
  end

  def list_programs
    return [] unless @available
    @calc.list_programs
  end
end

begin # BASIC setup
  @stk = Stack.new(0, 0, 0, 0, 0)
  @reg = %w[0 0 0 0 0 0 0 0 0 0]
  @fix = 4
  @sci = 6
  @eng = false
  @dot = true
  @mod = "Deg"
  @hlp = true
  @xrpn = XrpnInterface.new

  load(Dir.home+'/.t-rex.conf') if File.exist?(Dir.home+'/.t-rex.conf')
  @mod == "Deg" ? @stk.deg = true : @stk.deg = false

  @history = [" "]
  @u    = []
  @undo = false
end

begin # PANE setup
  begin
    @h, @w = IO.console.winsize
  rescue
    @h, @w = 24, 80  # Default fallback
  end

  #  pane = Rcurses::Pane.new(  x,  y,   width,  height,  fg,  bg)
  @p_bck  = Rcurses::Pane.new(  1,  1,      @w,      @h, 235, 235) # Back
  @p_inf  = Rcurses::Pane.new(  2,  2,      32,       1, 168, 238) # Info-line
  @p_lbl  = Rcurses::Pane.new(  2,  3,       1,       5, 250, 238) # LTZYX lables
  @p_key  = Rcurses::Pane.new(  2,  9,      32,      14,   0,   0) # Key panel
  @p_reg  = Rcurses::Pane.new(  2, 24,      32, @h - 24, 242,   0) # Regs
  @p_hlp  = Rcurses::Pane.new( 35,  2, @w - 35, @h -  2, 239,   0) # Help
  @p_hlp.scroll = true  # Enable scroll indicators
  @p_l    = Rcurses::Pane.new(  4,  3,      30,       1,  60, 235) # L
  @p_t    = Rcurses::Pane.new(  4,  4,      30,       1,  68, 233) # T
  @p_z    = Rcurses::Pane.new(  4,  5,      30,       1,  75, 233) # Z
  @p_y    = Rcurses::Pane.new(  4,  6,      30,       1, 117, 233) # Y
  @p_x    = Rcurses::Pane.new(  4,  7,      30,       1,   7,   0) # X
  @p_x.scroll = false  # Disable scroll indicators for X register

  @p_lbl.align = "r"
  @p_l.align   = "r"
  @p_t.align   = "r"
  @p_z.align   = "r"
  @p_y.align   = "r"
  @p_x.align   = "r"

  @p_lbl.text  = "ltzyx".i

  class String
    def t ; self.fg(111) ; end
    def k ; self.fg(214) ; end
    def s ; self.fg(242) ; end
  end

  keys  = "\n"
  keys += " r".t + "↓".k + " r".t + "↑".k + " x".t + "<".k + ">y".t
  keys += " + - * / \\ %".k + " c".t + "h".k + "s".t + " p".k + "i".t
  keys += "\n\n"
  keys += " y√x  x^2 x^3  e^x 10^x  redrw".s
  keys += "\n"
  keys += " y".t + "^".k + "x".t + "  1/".t + "x".k + " s".t + "q".k + "rt".t 
  keys += " l".t + "n".k + "  lo".t + "g".k + "   l".k + "astx".t
  keys += "\n\n"
  keys += " asin acos atan  R→P P→R  cstk".s
  keys += "\n"
  keys += "  s".t + "i".k + "n".t + "  c".t + "o".k + "s".t + "  t".t + "a".k + "n".t
  keys += "  r".k + "ad".t + " d".k + "eg".t + "  c".k + "lx".t
  keys += "\n\n"
  keys += " S".k + "to".t + " R".k + "cl".t + " s".k + "ci".t + " f".k + "ix".t
  keys += " u".k + "ndo".t + " H".k + "lp".t + " Q".k + "uit".t
  keys += "\n\n"
  keys += " X".k + "rpn".t + " (when in xrpn mode):".s
  keys += "\n"
  keys += " ^F".k + "act".t + " ^B".k + "ase".t + " P".k + "rog".t + " E".k + "dit".t  
  @p_key.text = keys
end

# FUNCTIONS
def history(entry)
  @history.push(entry.b, "  #{@stk.t}".i, "  #{@stk.z}".i, "  #{@stk.y}".i, "  #{@stk.x}".i.b, " ")
end
def histprint
  print = @history.join("\n ")
  @p_hlp.ix = 0 if @p_hlp.ix < 0
  @p_hlp.fg = 145
  @p_hlp.say(print)
  return print
end
def num_format(n) # THE NUMBER FORMAT FUNCTION
  if @eng
    # Engineering notation: exponents are multiples of 3
    return "0" if n == 0
    sign = n < 0 ? "-" : ""
    n_abs = n.abs

    # Calculate the exponent
    exponent = Math.log10(n_abs).floor

    # Adjust to nearest multiple of 3 (down)
    eng_exp = (exponent / 3).floor * 3

    # Calculate mantissa
    mantissa = n_abs / (10 ** eng_exp)

    # Format mantissa with appropriate decimal places
    mantissa_str = "%.#{@fix}f" % mantissa

    # Format with e notation
    if eng_exp == 0
      result = "#{sign}#{mantissa_str}"
    else
      result = "#{sign}#{mantissa_str}e%+03d" % eng_exp
    end

    # Apply locale formatting if needed
    if not @dot
      result.sub!(/\./, ',')
    end

    return result
  elsif n.abs >= 10 ** @sci.to_i
    n = "%.#{@sci}g" % n
  elsif n.abs <= 10 ** (1 / @sci.to_i) and n > 10
    n = "%.#{@sci}g" % n
  else
    n = n.round(@fix)
    n = "%.#{@fix}f" % n
    m = n[/^-/]
    m = "" if m == nil
    n.sub!(/-/, '')
    i = n[/\d*/]
    i.gsub!(/(\d)(?=(\d\d\d)+(?!\d))/, "\\1,")
    f = n.sub(/\d*\.(\d*)/, '\1')
    n = m + i + "." + f
    if not @dot
      n.gsub!(/,/, ' ')
      n.sub!(/\./, ',')
    end
  end
  return n
end
def main_getkey(c) # GET KEY FROM USER
  c == "" ? chr = getchr : chr = c
  case chr
  when 'ENTER'
    @stk.l = @stk.x
    @stk.y, @stk.z, @stk.t = @stk.x, @stk.y, @stk.z
    history("ENTER")
  when "'"
    @dot = !@dot
  when 'UP'   # Roll stack up
    @stk.rup
    history("↑")
  when 'DOWN' # Roll stack down
    @stk.rdn
    history("↓")
  when 'S-UP'  # Scroll help pane up
    @p_hlp.lineup
    @scroll_action = true
  when 'S-DOWN' # Scroll help pane down
    @p_hlp.linedown
    @scroll_action = true
  when 'PgUP'  # Page up in help pane
    @p_hlp.pageup
    @scroll_action = true
  when 'PgDOWN' # Page down in help pane
    @p_hlp.pagedown
    @scroll_action = true
  when 'HOME'  # Go to top of help pane
    @p_hlp.top if @hlp
    @scroll_action = true
  when 'END'   # Go to bottom of help pane
    @p_hlp.bottom if @hlp
    @scroll_action = true
  when '<', 'LEFT', 'RIGHT' # x<>y
    @stk.xy
    history("x<>y")
  when '+'
    @stk.add
    history("+")
  when '-'
    @stk.subtract
    history("-")
  when '*'
    @stk.multiply
    history("*")
  when '/'
    e = @stk.divide
    history("/")
    error ("Error: Divide by zero") if e == "Error"
  when '\\'   # \ (modulo)
    @stk.mod
    history("MOD")
  when '%'    # 100*x/y
    e = @stk.percent
    history("%")
    error ("Error: Divide by zero") if e == "Error"
  when 'h'    # Change sign
    @stk.chs
    history("chs")
  when 'p'    # pi
    @stk.l = @stk.x
    @stk.pi
    history("pi")
  when '^'    # y^x
    @stk.pow
    history("y^x")
  when 'C-^'  # y^(1/x)
    e = @stk.root 
    history("y^(1/x)")
    error ("Error: Divide by zero") if e == "Error"
  when 'x'    # 1/x
    e = @stk.recip
    history("1/x")
    error ("Error: Divide by zero") if e == "Error"
  when 'C-X'  # x^2
    @stk.sqr  
    history("x^2")
  when 'q'    # Square root
    e = @stk.sqrt
    history("sqrt")
    error ("Error: Imaginary number") if e == "Error"
  when 'C-Q'  # x^3
    @stk.cube
    history("x^3")
  when 'n'    # ln(x)
    if @xrpn.mode == :xrpn
      result = @xrpn.execute_with_sync("ln", @stk)
      if result.is_a?(Array)
        @stk.t, @stk.z, @stk.y, @stk.x = result
      else
        error(result)
      end
    else
      e = @stk.ln
      error ("Error: Negative x") if e == "Error"
    end
    history("ln")
  when 'C-N'  # e^x
    if @xrpn.mode == :xrpn
      result = @xrpn.execute_with_sync("exp", @stk)
      if result.is_a?(Array)
        @stk.t, @stk.z, @stk.y, @stk.x = result
      else
        error(result)
      end
    else
      @stk.ex
    end
    history("e^x")
  when 'g'    # log(x)
    if @xrpn.mode == :xrpn
      result = @xrpn.execute_with_sync("log", @stk)
      if result.is_a?(Array)
        @stk.t, @stk.z, @stk.y, @stk.x = result
      else
        error(result)
      end
    else
      e = @stk.log
      error ("Error: Negative x") if e == "Error"
    end
    history("log")
  when 'C-G'  # 10^x
    if @xrpn.mode == :xrpn
      result = @xrpn.execute_with_sync("alog", @stk)
      if result.is_a?(Array)
        @stk.t, @stk.z, @stk.y, @stk.x = result
      else
        error(result)
      end
    else
      @stk.tenx
    end
    history("10^x")
  when 'l'    # Recall Lastx (l) to x
    @stk.lift
    @stk.x = @stk.l
    history("lastx")
  when 'C-L'  # Redraw
    refresh
  when 'i'
    @stk.sin
    history("sin")
  when 'TAB' # Same as 'C-I'
    e = @stk.asin
    history("asin")
    error ("Error: Number out of domain") if e == "Error"
  when 'o'
    @stk.cos
    history("cos")
  when 'C-O'
    e = @stk.acos
    history("acos")
    error ("Error: Number out of domain") if e == "Error"
  when 'a'
    @stk.tan
    history("tan")
  when 'C-A'
    @stk.atan
    history("atan")
  when 'r'     # Rad mode
    @mod     = "Rad"
    @stk.deg = false
    history("Rad")
  when 'C-R'   # R->P
    e = @stk.rp
    history("R->P")
    error ("Error: Divide by zero") if e == "Error"
  when 'd'     # Deg mode
    @mod     = "Deg"
    @stk.deg = true
    history("Deg")
  when 'C-D'   # P->R
    @stk.pr
    history("P->R")
  when 'c', 'BACK'
    @stk.x = 0
  when 'C-C'   # Clear stack
    @stk.x = 0
    @stk.y = 0
    @stk.z = 0
    @stk.t = 0
    @stk.l = 0
    history("CLR")
  when 'M'
    @reg = %w[0 0 0 0 0 0 0 0 0 0] 
  when 'S' # Store to Reg
    @p_x.say(" Store x in Reg #(0-9)")
    r = getchr
    if r =~ /[0-9]/
      @reg[r.to_i] = @stk.x
    end
    history("STO #{r}")
  when 'R'  # Recall from Reg
    @p_x.say(" Recall from Reg #(0-9)")
    r = getchr
    if r =~ /[0-9]/
      @stk.lift
      @stk.x = @reg[r.to_i].to_f
    end
    history("RCL #{r}")
  when 's'     # Set Sci size/limit
    @p_x.say(" Sci notation limit (2-9)")
    s = getchr
    if s =~ /[2-9]/
      @sci = s.to_i
    end
    history("Sci #{s}")
  when 'f'     # Set Fix size
    @p_x.say(" Fixed decimals (0-9)")
    f = getchr
    if f =~ /[0-9]/
      @fix = f.to_i
    end
    history("Fix #{f}")
  when 'C-E'   # Toggle ENG mode
    @eng = !@eng
    mode = @eng ? "ON" : "OFF"
    history("ENG #{mode}")
  when 'u'     # Undo
    unless @u.empty?
      @stk = @u.last.dup
      @u.pop
      @undo = true
    end
    history("UNDO")
  when 'y'
    begin
      @p_x.bg = 250
      @p_x.refresh
      system("echo '#{@stk.x}' | xclip")
      sleep(0.1)
      @p_x.bg = 0
      @p_x.refresh
    rescue
      @p_x.text = " Install xclip to yank"
      @p_x.refresh
      getchr
    end
  when 'Y'
    begin
      @p_x.bg = 244
      @p_x.refresh
      mem = ""
      10.times do |i|
        reg = @reg[i]
        mem += "#{reg}\n"
      end
      system("echo '#{mem}' | xclip")
      sleep(0.1)
      @p_x.bg = 0
      @p_x.refresh
    rescue
      @p_x.text = " Install xclip to yank"
      @p_x.refresh
      getchr
    end
  when 'H' # Toggle help/histprint
    @hlp = !@hlp
  when 'C-B'
    # Check if we're in XRPN mode first
    if @xrpn.available? && @xrpn.mode == :xrpn
      # XRPN base conversion mode
      @p_hlp.fg = 168
      @p_hlp.clear
      @p_hlp.text = "XRPN Base Conversion\n\nChoose conversion:\n"
      @p_hlp.text += "  h - Convert to hexadecimal\n"
      @p_hlp.text += "  b - Convert to binary\n"
      @p_hlp.text += "  o - Convert to octal\n"
      @p_hlp.text += "  d - Convert to decimal\n"
      @p_hlp.text += "  ESC - Cancel\n\n"
      @p_hlp.text += "Choice> "
      @p_hlp.refresh
      
      f = getchr
      
      output = "\n"
      conversion_done = false
      case f
      when 'h'
        result = @xrpn.execute_with_sync("dechex", @stk)
        if result.is_a?(Array)
          @stk.t, @stk.z, @stk.y, @stk.x = result
          output += "Converted to hexadecimal: #{@stk.x}\n"
          conversion_done = true
          pstack  # Update stack display
        else
          output += "Error: #{result}\n"
        end
        history("hex")
      when 'b'
        result = @xrpn.execute_with_sync("decbin", @stk)
        if result.is_a?(Array)
          @stk.t, @stk.z, @stk.y, @stk.x = result
          output += "Converted to binary: #{@stk.x}\n"
          conversion_done = true
          pstack  # Update stack display
        else
          output += "Error: #{result}\n"
        end
        history("bin")
      when 'o'
        result = @xrpn.execute_with_sync("decoct", @stk)
        if result.is_a?(Array)
          @stk.t, @stk.z, @stk.y, @stk.x = result
          output += "Converted to octal: #{@stk.x}\n"
          conversion_done = true
          pstack  # Update stack display
        else
          output += "Error: #{result}\n"
        end
        history("oct")
      when 'd'
        result = @xrpn.execute_with_sync("hexdec", @stk)
        if result.is_a?(Array)
          @stk.t, @stk.z, @stk.y, @stk.x = result
          output += "Converted to decimal: #{@stk.x}\n"
          conversion_done = true
          pstack  # Update stack display
        else
          output += "Error: #{result}\n"
        end
        history("dec")
      when 'ESC'
        output += "Conversion cancelled\n"
      else
        output += "Invalid choice\n"
      end
      
      # Show result
      @p_hlp.text += output
      @p_hlp.text += "\nPress any key to continue..."
      @p_hlp.refresh
      getchr
      @hlp ? help : @p_hlp.clear
      @p_hlp.refresh
    elsif !@hlp
      # Original T-REX history browsing
      loop do
        @p_hlp.ix -= @h + 3
        histprint
        break if getchr != 'C-B'
      end
    else
      # Help mode, provide user feedback
      error("Ctrl+B: In XRPN mode for base conversion, or history browsing when not in help")
    end
  when 'C-P'
    cont = histprint.pure
    File.write(Dir.home+'/t-rex.txt', cont)
    error ("History written to t-rex.txt")
  when '@' # Ruby console
    @p_hlp.fg = 168
    loop do
      @p_hlp.say("")
      @p_hlp.prompt = " Ruby: "
      @p_hlp.editline
      Rcurses::Cursor.set(4,36)
      x = @stk.x
      y = @stk.y
      z = @stk.z
      t = @stk.t
      l = @stk.l
      begin
        eval(@p_hlp.text)
      rescue
      end
      break if getchr == "ESC"
    end
    @p_hlp.fg = 239
    getchr
    @hlp ? help : @p_hlp.say("")
  when 'X' # Toggle T-REX/XRPN mode
    if @xrpn.available?
      if @xrpn.mode == :trex
        @xrpn.sync_stack_to_xrpn(@stk)
        result = @xrpn.toggle_mode
        if result.is_a?(String)
          error(result)
        else
          history("Mode: XRPN")
        end
      else
        t, z, y, x = @xrpn.sync_stack_from_xrpn
        @stk.t, @stk.z, @stk.y, @stk.x = t, z, y, x
        @xrpn.toggle_mode
        history("Mode: T-REX")
      end
    else
      error("XRPN not available. See help for installation instructions.")
    end
  when 'C-F' # Factorial (XRPN only)
    if @xrpn.available? && @xrpn.mode == :xrpn
      # Safety check for huge factorials that can freeze the app
      if @stk.x > 170
        error("Error: Factorial too large (max 170)")
      elsif @stk.x < 0
        error("Error: Factorial of negative number")
      elsif @stk.x != @stk.x.to_i
        error("Error: Factorial requires integer")
      else
        result = @xrpn.execute_with_sync("fact", @stk)
        if result.is_a?(Array)
          @stk.t, @stk.z, @stk.y, @stk.x = result
        else
          error(result)
        end
        history("fact")
      end
    end
  when 'P' # XRPN Program execution (XRPN only)
    if @xrpn.available? && @xrpn.mode == :xrpn
      @p_hlp.fg = 168
      @p_hlp.clear
      program_mode = true
      
      # Display instructions
      @p_hlp.text = "XRPN Program Execution\n\nCommands:\n"
      @p_hlp.text += "  l <file>   - Load XRPN program from file\n"
      @p_hlp.text += "  x <name>   - Execute program by name\n"
      @p_hlp.text += "  r <cmd>    - Run single XRPN command\n"
      @p_hlp.text += "  s          - Show current stack\n"
      @p_hlp.text += "  p          - List loaded programs\n"
      @p_hlp.text += "  status     - Show XRPN status\n"
      @p_hlp.text += "  ESC        - Exit program mode\n\n"
      @p_hlp.text += "Program> "
      @p_hlp.refresh
      
      input_buffer = ""
      while program_mode
        chr = getchr
        case chr
        when 'ESC'
          program_mode = false
        when 'S-UP'  # Scroll up in program mode
          @p_hlp.lineup
        when 'S-DOWN' # Scroll down in program mode
          @p_hlp.linedown
        when 'PgUP'  # Page up in program mode
          @p_hlp.pageup
        when 'PgDOWN' # Page down in program mode
          @p_hlp.pagedown
        when 'HOME'  # Go to top in program mode
          @p_hlp.top
        when 'END'   # Go to bottom in program mode
          @p_hlp.bottom
        when 'ENTER'
          cmd = input_buffer.strip
          input_buffer = ""
          
          # Process command
          output = "\n"
          case cmd.split.first
          when 'l' # Load program
            filename = cmd.split[1]
            if filename
              result = @xrpn.load_program(filename)
              output += (result == true) ? "Program loaded successfully\n" : "#{result}\n"
            else
              output += "Usage: l <filename>\n"
            end
          when 'x' # Execute program
            program_name = cmd.split[1]
            if program_name
              @xrpn.sync_stack_to_xrpn(@stk)
              result = @xrpn.execute_program(program_name)
              if result == true
                t, z, y, x = @xrpn.sync_stack_from_xrpn
                @stk.t, @stk.z, @stk.y, @stk.x = t, z, y, x
                output += "Program executed successfully\n"
                pstack  # Update stack display
              else
                output += "#{result}\n"
              end
            else
              output += "Usage: x <program_name>\n"
            end
          when 'r' # Run single command
            xrpn_cmd = cmd[2..-1]
            if xrpn_cmd && !xrpn_cmd.strip.empty?
              @xrpn.sync_stack_to_xrpn(@stk)
              result = @xrpn.execute_xrpn_command(xrpn_cmd.strip)
              if result == true
                t, z, y, x = @xrpn.sync_stack_from_xrpn
                @stk.t, @stk.z, @stk.y, @stk.x = t, z, y, x
                output += "Command '#{xrpn_cmd.strip}' executed successfully\n"
                pstack  # Update stack display
              else
                output += "#{result}\n"
              end
            else
              output += "Usage: r <xrpn_command>\n"
            end
          when 's' # Show stack
            output += "Stack: T=#{@stk.t} Z=#{@stk.z} Y=#{@stk.y} X=#{@stk.x}\n"
          when 'p' # List programs
            programs = @xrpn.list_programs
            output += programs.empty? ? "No programs loaded\n" : "Loaded programs: #{programs.join(', ')}\n"
          when 'status' # Show XRPN status
            output += "XRPN Status: #{@xrpn.debug_status}\n"
            output += "Stack sync: T=#{@stk.t} Z=#{@stk.z} Y=#{@stk.y} X=#{@stk.x}\n"
          when nil, ''
            # Empty command, do nothing
          else
            output += "Unknown command. Use ESC to exit.\n"
          end
          
          # Update display
          @p_hlp.text += output + "\nProgram> "
          @p_hlp.refresh
        when 'BACK', 'DEL'
          unless input_buffer.empty?
            input_buffer.chop!
            @p_hlp.text = @p_hlp.text[0..-2]  # Remove last character
            @p_hlp.refresh
          end
        when String
          if chr.length == 1 && chr =~ /[ -~]/  # Printable characters
            input_buffer += chr
            @p_hlp.text += chr
            @p_hlp.refresh
          end
        end
      end
      
      @p_hlp.fg = 239
      @hlp ? help : @p_hlp.clear
      @p_hlp.refresh
    end
  when 'E' # XRPN Program editor (XRPN only)
    if @xrpn.available? && @xrpn.mode == :xrpn
      @p_hlp.fg = 168
      @p_hlp.clear
      editor_mode = true
      current_program = []
      program_name = ""
      
      # Display instructions
      @p_hlp.text = "XRPN Program Editor\n\nCommands:\n"
      @p_hlp.text += "  new <name> - Create new program\n"
      @p_hlp.text += "  add <line> - Add line to current program\n"
      @p_hlp.text += "  list       - List current program\n"
      @p_hlp.text += "  del <n>    - Delete line n\n"
      @p_hlp.text += "  save       - Save current program\n"
      @p_hlp.text += "  run        - Run current program\n"
      @p_hlp.text += "  clear      - Clear current program\n"
      @p_hlp.text += "  ESC        - Exit editor\n\n"
      @p_hlp.text += "Editor> "
      @p_hlp.refresh
      
      input_buffer = ""
      while editor_mode
        chr = getchr
        case chr
        when 'ESC'
          editor_mode = false
        when 'S-UP'  # Scroll up in editor mode
          @p_hlp.lineup
        when 'S-DOWN' # Scroll down in editor mode
          @p_hlp.linedown
        when 'PgUP'  # Page up in editor mode
          @p_hlp.pageup
        when 'PgDOWN' # Page down in editor mode
          @p_hlp.pagedown
        when 'HOME'  # Go to top in editor mode
          @p_hlp.top
        when 'END'   # Go to bottom in editor mode
          @p_hlp.bottom
        when 'ENTER'
          cmd = input_buffer.strip
          input_buffer = ""
          
          # Process command
          output = "\n"
          case cmd.split.first
          when 'new' # New program
            program_name = cmd.split[1]
            if program_name
              current_program = []
              output += "New program '#{program_name}' created\n"
            else
              output += "Usage: new <program_name>\n"
            end
          when 'add' # Add line
            line = cmd[4..-1]
            if line && !line.strip.empty? && !program_name.empty?
              current_program << line.strip
              output += "Line #{current_program.length} added: #{line.strip}\n"
            elsif program_name.empty?
              output += "Create a program first with 'new <name>'\n"
            else
              output += "Usage: add <program_line>\n"
            end
          when 'list' # List program
            if current_program.empty?
              output += "No program loaded\n"
            else
              output += "Program '#{program_name}':\n"
              current_program.each_with_index do |line, i|
                output += "  #{i+1}: #{line}\n"
              end
            end
          when 'del' # Delete line
            line_num = cmd.split[1].to_i
            if line_num > 0 && line_num <= current_program.length
              deleted = current_program.delete_at(line_num - 1)
              output += "Deleted line #{line_num}: #{deleted}\n"
            else
              output += "Invalid line number\n"
            end
          when 'save' # Save program
            if !current_program.empty? && !program_name.empty?
              program_text = current_program.join("\n")
              filename = "#{program_name}.xrpn"
              begin
                File.write(filename, program_text)
                result = @xrpn.load_program(filename)
                output += (result == true) ? "Program saved and loaded: #{filename}\n" : "Saved but load failed: #{result}\n"
              rescue => e
                output += "Save failed: #{e.message}\n"
              end
            else
              output += "No program to save\n"
            end
          when 'run' # Run program
            if !current_program.empty?
              @xrpn.sync_stack_to_xrpn(@stk)
              output += "Executing program line by line:\n"
              success = true
              current_program.each_with_index do |line, i|
                line = line.strip
                next if line.empty?
                result = @xrpn.execute_xrpn_command(line)
                if result == true
                  output += "  #{i+1}: #{line} - OK\n"
                else
                  output += "  #{i+1}: #{line} - #{result}\n"
                  success = false
                  break
                end
              end
              if success
                t, z, y, x = @xrpn.sync_stack_from_xrpn
                @stk.t, @stk.z, @stk.y, @stk.x = t, z, y, x
                output += "Program executed successfully\n"
                pstack  # Update stack display
              else
                output += "Program execution stopped due to error\n"
              end
            else
              output += "No program to run\n"
            end
          when 'clear' # Clear program
            current_program = []
            program_name = ""
            output += "Program cleared\n"
          when nil, ''
            # Empty command, do nothing
          else
            output += "Unknown command. Use ESC to exit.\n"
          end
          
          # Update display
          @p_hlp.text += output + "\nEditor> "
          @p_hlp.refresh
        when 'BACK', 'DEL'
          unless input_buffer.empty?
            input_buffer.chop!
            @p_hlp.text = @p_hlp.text[0..-2]  # Remove last character
            @p_hlp.refresh
          end
        when String
          if chr.length == 1 && chr =~ /[ -~]/  # Printable characters
            input_buffer += chr
            @p_hlp.text += chr
            @p_hlp.refresh
          end
        end
      end
      
      @p_hlp.fg = 239
      @hlp ? help : @p_hlp.clear
      @p_hlp.refresh
    end
  when 'Q' # QUIT 
    Rcurses.clear_screen
    Rcurses::Cursor.show
    exit 0
  when /[0-9.,]/ # Go to entry mode for x
    @stk.lift
    pstack
    number, c = entry(chr)
    if number != ""
      @stk.l = @stk.x
      @stk.x = number
    end
    history(number.to_s)
    @stk.drop if c == "ENTER"
    if %w[< + - * / \ % ^ x C-X q C-Q n C-N g C-G i C-I o C-O a C-A c C-C].include?(c)
      @stk.drop
      main_getkey(c)
    end
  end
end
def entry(chr) # X REGISTER ENTRY
  num = chr
  pos = 1
  while %w[0 1 2 3 4 5 6 7 8 9 . , h H e RIGHT LEFT HOME END DEL BACK WBACK LDEL].include?(chr)
    @p_x.clear
    @p_x.say(num)
    # Position cursor at the right place in the X register (row 7, right-aligned in 30-char width)
    cursor_col = 33 - num.length + pos
    Rcurses::Cursor.set(7, cursor_col)
    Rcurses::Cursor.show
    chr = getchr
    case chr
    when 'RIGHT'
      pos += 1 unless pos >= num.length
    when 'LEFT'
      pos -= 1 unless pos == 0
    when 'HOME'
      pos = 0
    when 'END'
      pos = num.length
    when 'DEL'
      unless pos == 0
        pos -= 1
        num[pos] = ""
      end
    when 'BACK'
      unless pos == 0
        pos -= 1
        num[pos - 1] = ""
      end
    when 'WBACK'
      unless pos == 0
        until num[pos - 1] == " " or pos == 0
          pos -= 1
          num[pos] = ""
        end
        if num[pos - 1] == " "
          pos -= 1
          num[pos] = ""
        end
      end
    when 'LDEL'
      num = ""
      pos = 0
    when 'h'
      if num[0] == "-"
        num[0] = "" 
        pos -= 1
      else
        num.insert(0, "-")
        pos += 1
      end
    when 'H'
      num.insert(pos,"-")
      pos += 1
    when 'e'
      num.insert(pos,chr)
      pos += 1
    when /[0-9.,]/
      num.insert(pos,chr)
      pos += 1
    end
  end
  num = "" if %w[DOWN UP].include?(chr)
  num.gsub!(/,/, '.')
  if num.include?("e")
    base, exp_str = num.split("e")
    num = (base.to_f * (10 ** exp_str.to_i)).to_s
  end
  num != "" ? number = num.to_f : number = ""
  Rcurses::Cursor.hide
  return number, chr
end
def refresh # REFRESH ALL PANES
  @p_bck.refresh
  @p_inf.refresh
  @p_lbl.refresh
  @p_key.refresh
  @p_reg.refresh
  help
  @p_l.refresh  
  @p_t.refresh  
  @p_z.refresh  
  @p_y.refresh  
  @p_x.refresh  
end
def pstack # PRINT STACK (XYZTL)
  @p_l.say(num_format(@stk.l))  
  @p_t.say(num_format(@stk.t))  
  @p_z.say(num_format(@stk.z))  
  @p_y.say(num_format(@stk.y))  
  @p_x.say(num_format(@stk.x).b)  
end
def pregs # PRINT CONTENT OF REGS (0-9)
  @p_reg.text = "\n"
  10.times do |i| 
    r = num_format(@reg[i].to_f)
    @p_reg.text += " R##{i}".i + "#{r}".rjust(27) + "\n" 
  end
  @p_reg.refresh
end
def error(err) # PRINT ERRORS TO X
  # Truncate error message to fit in X register pane (width 30)
  truncated_err = err.length > 30 ? err[0..26] + "..." : err
  @p_x.say(truncated_err)
  @history.insert(-2, err)  # Store full error in history
  getchr
end
def conf_write # WRITE TO .t-rex.conf
  conf  = "@fix = #{@fix}\n"
  conf += "@sci = #{@sci}\n"
  @eng ? e = "true" : e = "false"
  conf += "@eng = #{e}\n"
  @dot ? d = "true" : d = "false"
  conf += "@dot = #{d}\n"
  conf += "@mod = \"#{@mod}\"\n"
  conf += "@stk = Stack.new(#{@stk.x}, #{@stk.y}, #{@stk.z}, #{@stk.t}, #{@stk.l})\n"
  conf += "@reg = %w[#{@reg[0]} #{@reg[1]} #{@reg[2]} #{@reg[3]} #{@reg[4]} #{@reg[5]} #{@reg[6]} #{@reg[7]} #{@reg[8]} #{@reg[9]}]\n"
  @hlp ? h = "true" : h = "false"
  conf += "@hlp = #{h}\n"
  File.write(Dir.home+'/.t-rex.conf', conf)
end

# MAIN PROGRAM
# Initialize rcurses (required for rcurses 6.0.0+)
Rcurses.init!
refresh
Rcurses::Cursor.hide
begin # Capture main loop
  loop do # Main loop
    eng_status = @eng ? "ENG" : ""
    @p_inf.say("  #{@xrpn.mode_display} #{@mod} #{eng_status} Sci=#{@sci} Fix=#{@fix}".i)
    pstack
    pregs
    @t = @stk.dup
    @scroll_action = false
    main_getkey("") # Get key input from user 
    help unless @scroll_action
    @u.push(@t.dup) if @t != @stk and @undo == false
    @undo = false
    begin
      h1, w1 = IO.console.winsize
      if h1 != @h or w1 != @w # Refresh on terminal resize 
        @h, @w = h1, w1
        refresh
      end
    rescue
      # Ignore winsize errors in non-terminal environments
    end
  end
ensure # Write to .t-rex.conf on exit
  conf_write
end

# vim: set sw=2 sts=2 et fdm=syntax fdn=2 fcs=fold\:\ :
